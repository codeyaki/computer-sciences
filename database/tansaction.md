# 트랜잭션 (tansaction)
## 트랜잭션이란?
- 트랜잭션이란 서비스에서 쪼갤수 없는 쪼갤수없는 로직의 단위이다.
- 예로 은행업무에서 이체를 할때 두가지 로직을 수행하게 된다.
  1. A의 통장에 X만큼의 금액을 감소시킨다.
  2. B의 통장에 X만큼의 금액을 증가시킨다.
  - 이 두개의 로직중 한개만 동작해서는 안되고 항상 두개가 동작하거나 두개다 동작하지 않아야 한다.
  - 따라서 이 두개의 로직은 하나의 트랜잭션으로 묶여야 한다.

## 트랜잭션의 속성 ACID
- 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 영속성(Durability)이 존재한다. 이 4가지 속성의 앞글자를 따서 ACID라고 부른다.
  - 원자성(Atomicity)  
    - 트랜잭션에 속한 각각의 문(데이터를 읽기, 쓰기, 업데이트 또는 삭제하기 위함)을 하나의 단위로 취급합니다. 문 전체를 실행하거나 그 문의 어떤 부분도 실행하지 않거나 둘 중 하나입니다. 이 속성이 있으면 예컨대 스트리밍 데이터 소스가 스트리밍 중에 갑자기 오류를 일으키더라도 데이터 손실과 손상이 방지됩니다.
  - 일관성(Consistency)  
    - 트랜잭션이 테이블에 변경 사항을 적용할 때 미리 정의된, 예측할 수 있는 방식만 취합니다. 트랜잭션 일관성이 확보되면 데이터 손상이나 오류 때문에 테이블 무결성에 의도치 않은 결과가 생기지 않습니다.
  - 격리(Isolation)  
    - 여러 사용자가 같은 테이블에서 모두 동시에 읽고 쓰기 작업을 할 때, 각각의 트랜잭션을 격리하면 동시 트랜잭션이 서로 방해하거나 영향을 미치지 않습니다. 각각의 요청이 실제로는 모두 동시에 발생하더라도, 마치 하나씩 발생하는 것처럼 발생할 수 있습니다.
  - 영속성(Durability)  
    - 트랜잭션 실행으로 인해 데이터에 적용된 변경 사항이 저장되도록 보장합니다. 시스템 오류가 발생해도 마찬가지입니다.
    
## 트랜잭션 동작
- 커밋 (Commit)
  - 트랜잭션 작업을 전부 성공하고 영구적으로 반영시키는 것
- 롤백 (Rollback)
  - 트랜잭션의 작업 중 오류가 발생하여 모든 트랜잭션 작업을 수행하기 이전으로 되돌리는 것!
  - 위의 은행의 예에서 2번 작업을 하는 중 오류가 발생하면 1번의 작업도 되돌린다.

## 트랜잭션 격리 수준 (Isolation Lelvel)
- 여러 트랙잭션이 발생하여 처리할때 수행할 방식으로 숫자가 높아질수록 동시성(성능)은 떨어지는 대신 고립성이 상승한다 (= 데이터의 정합성이 높다)
- 오라클은 2.READ COMMITTED가 기본사용, MySQL은 3.REPEATABLE READ를 기본으로 사용한다.
1. READ UNCOMMITTED
2. READ COMMITTED
3. REPEATABLE READ
4. SERIALIZABLE

### 1. Read UNCOMMITTED
- 트랜잭션의 커밋, 롤백과 관계없이 변경사항을 전부 read하는 방식이다.
- 더티 리드(Dirty Read)가 발생할 수 있다.
- 데이터 정합성에 문제가 많기 떄문에 사용하지 않는 것을 추천한다.

> Dirty Read?
> 아직 트랜잭션이 끝나지 않은 트랜잭션의 작업이 다른 트랜잭션에 적용되는 문제이다.
> 0. X.name = 바위
> 1. A트랜잭션에서 X의 name을 가위로 변경함
> 2. B트랜잭션에서 X를 조회함. (X.name = 가위)
> 3. A트랜잭션이 롤백됨 
> 4. B트랜잭션에서 X의 데이터가 맞지 않아 문제 발생
> 이러한 문제가 발생하여 Read UNCOMMITTED은 사용하지 않는 것이 좋다.

### 2. READ COMMITTED
- 1. Read UNCOMMITTED에서 발생하는 더티리드를 해결하기 위해서 커밋, 롤백이 된 데이터만 READ하는 방식이다.
- Undo 영역에 변경된 데이터를 저장하고 그것을 조회시키는 방식
- 더티리드는 해결되었지만 다른 문제인 NON-REPEATABLE 문제가 발생할 수 있다.

> NON_REPEATABLE?
> 같은 트랜잭션내에서 같은 데이터를 READ했을때 다르게 나오는 문제이다.
> 0. X.name = 바위
> 1. A트랜잭션에서 X를 조회함. (X.name = 바위)
> 2. B트랜잭션에서 X의 name읇 가위로 변경하고 Commit
> 3. A트랜잭션에서 X를 다시 조회함. (X.name = 가위)
> 이러한 문제는 정합성을 깨게 되는 문제이다.

### 3. REPEATABLE READ
- NON-REPEATABLE 문제를 해결하기 위해서 나온 방식으로 해당 트랜잭션이 시작하기 이전에 커밋된 작업들만 반영하여 트랜잭션을 처리하는 방식이다.
- 실제 테이블을 변경하고 UNDO 공간을 백업으로 사용 (일정 기간 후 제거)
- MVCC(Multi Version Concurrency Control) 방식이라고 불린다.
- MySQL에서 사용하고 있는 방법이다.
- Phantom Read 문제가 발생한다.

> PHANTOM READ?
> 다른 트랜잭션에서 추가한 데이터가 보였다가 안보였다가 하는 문제이다.

### 4. SERIALIZABLE
- REPEATABLE READ에서 발생하는 Phantom Read 문제를 해결하기 위해서 사용하는 방식으로 트랙잭션에서 접근한 데이터는 다른 트랜잭션에서 사용할 수 없더록 잠그는 방식이다. (공유 잠금)
- 동시 접근이 불가하다 보니 동시성이 매우 떨어진다. (성능이 떨어진다.)
- 성능이 떨어져서 일반적인 상황에서는 사용하지 않는다.


## 참고자료  
  
http://wiki.hash.kr/index.php/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98
